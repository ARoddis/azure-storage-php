<html>
    <head>
        <script
            type="text/javascript"
            src="../../../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../../../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../../../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../../../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../../../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php

/**
 * LICENSE: The MIT License (the &quot;License&quot;)
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * https://github.com/azure/azure-storage-php/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * PHP version 5
 *
 * @category  Microsoft
 * @package   MicrosoftAzure\Storage\Table\Internal
 * @author    Azure Storage PHP SDK &lt;dmsh@microsoft.com&gt;
 * @copyright 2016 Microsoft Corporation
 * @license   https://github.com/azure/azure-storage-php/LICENSE
 * @link      https://github.com/azure/azure-storage-php
 */
 
namespace MicrosoftAzure\Storage\Table\Internal;

use MicrosoftAzure\Storage\Common\Internal\Utilities;
use MicrosoftAzure\Storage\Common\Internal\Resources;
use MicrosoftAzure\Storage\Table\Models\EdmType;
use MicrosoftAzure\Storage\Table\Models\Entity;

/**
 * Serializes and unserializes results from table wrapper calls
 *
 * @ignore
 * @category  Microsoft
 * @package   MicrosoftAzure\Storage\Table\Internal
 * @author    Azure Storage PHP SDK &lt;dmsh@microsoft.com&gt;
 * @copyright 2016 Microsoft Corporation
 * @license   https://github.com/azure/azure-storage-php/LICENSE
 * @link      https://github.com/azure/azure-storage-php
 */
class AtomReaderWriter implements IAtomReaderWriter
{
    private $_atomNamespaceName;
    private $_dataServicesNamespaceName;
    private $_dataServicesMetadataNamespaceName;
    private $_xmlVersion;
    private $_xmlEncoding;
    private $_dataServicesPrefix;
    private $_dataServicesMetadataPrefix;
    
    /**
     * Generates the atom XML properties.
     *
     * @param \XmlWriter $xmlw       The XML writer.
     * @param array      $properties The atom properties.
     *
     * @return void
     */
    private function _generateProperties(\XmlWriter $xmlw, array $properties = null)
    {
        foreach ($properties as $key =&gt; $value) {
            $content    = key($value);
            $attributes = $value[$content];
            $xmlw-&gt;startElementNS($this-&gt;_dataServicesPrefix, $key, null);
            if (!is_null($attributes)) {
                foreach ($attributes as $attribute =&gt; $attributeValue) {
                    $xmlw-&gt;writeAttributeNS(
                        $this-&gt;_dataServicesMetadataPrefix,
                        $attribute,
                        null,
                        $attributeValue
                    );
                }
            }
            $xmlw-&gt;text($content);
            $xmlw-&gt;endElement();
        }
    }

    /**
     * Serializes the atom into XML representation.
     *
     * @param array $properties The atom properties.
     *
     * @return string
     */
    private function _serializeAtom(array $properties)
    {
        $xmlw = new \XmlWriter();
        $xmlw-&gt;openMemory();
        $xmlw-&gt;setIndent(true);
        $xmlw-&gt;startDocument(
            strtoupper($this-&gt;_xmlVersion),
            $this-&gt;_xmlEncoding,
            'yes'
        );
        $xmlw-&gt;startElementNS(null, 'entry', $this-&gt;_atomNamespaceName);
        $xmlw-&gt;writeAttribute(
            &quot;xmlns:$this-&gt;_dataServicesPrefix&quot;,
            $this-&gt;_dataServicesNamespaceName
        );
        $xmlw-&gt;writeAttribute(
            &quot;xmlns:$this-&gt;_dataServicesMetadataPrefix&quot;,
            $this-&gt;_dataServicesMetadataNamespaceName
        );
        $xmlw-&gt;writeElement('title');
        $xmlw-&gt;writeElement('updated', Utilities::isoDate());
        $xmlw-&gt;startElement('author');
        $xmlw-&gt;writeElement('name');
        $xmlw-&gt;endElement();
        $xmlw-&gt;writeElement('id');
        $xmlw-&gt;startElement('content');
        $xmlw-&gt;writeAttribute('type', Resources::XML_CONTENT_TYPE);
        $xmlw-&gt;startElementNS(
            $this-&gt;_dataServicesMetadataPrefix,
            'properties',
            null
        );
        $this-&gt;_generateProperties($xmlw, $properties);
        $xmlw-&gt;endElement();
        $xmlw-&gt;endElement();
        $xmlw-&gt;endElement();
        
        return $xmlw-&gt;outputMemory(true);
    }
    
    /**
     * Creates new SimpleXml from Atom XML and registers the namespaces prefixes.
     *
     * @param string $body Response from HTTP call.
     *
     * @return \SimpleXml
     */
    private function _parseBody($body)
    {
        $xml = simplexml_load_string($body);

        if ($xml !== false) {
            $xml-&gt;registerXPathNamespace(
                $this-&gt;_dataServicesPrefix,
                $this-&gt;_dataServicesNamespaceName
            );
            $xml-&gt;registerXPathNamespace(
                $this-&gt;_dataServicesMetadataPrefix,
                $this-&gt;_dataServicesMetadataNamespaceName
            );
        }

        return $xml;
    }
    
    /**
     * Parses one table entry and returns the table name.
     *
     * @param \SimpleXmlElement $result The original XML body loaded in XML.
     *
     * @return string
     */
    private function _parseOneTable(\SimpleXmlElement $result)
    {
        $query     = &quot;.//$this-&gt;_dataServicesMetadataPrefix:properties/&quot;;
        $query    .= &quot;$this-&gt;_dataServicesPrefix:TableName&quot;;
        $tableName = $result-&gt;xpath($query);
        $table     = (string)$tableName[0];
        
        return $table;
    }
    
    /**
     * Gets entry nodes from the XML body.
     *
     * @param \SimpleXmlElement $body The original XML body loaded in XML.
     *
     * @return array
     */
    private function _getRawEntries(\SimpleXmlElement $body)
    {
        $rawEntries = array();
        
        if (!is_null($body) &amp;&amp; $body-&gt;entry) {
            $rawEntries = $body-&gt;entry;
        }
        
        return $rawEntries;
    }
    
    /**
     * Parses an entity entry from given SimpleXML object.
     *
     * @param \SimpleXmlElement $result The SimpleXML object representing the entity.
     *
     * @return Entity
     */
    private function _parseOneEntity(\SimpleXmlElement $result)
    {
        $prefix = $this-&gt;_dataServicesMetadataPrefix;
        $prop   = $result-&gt;content-&gt;xpath(&quot;.//$prefix:properties&quot;);
        $prop   = $prop[0]-&gt;children($this-&gt;_dataServicesNamespaceName);
        $entity = new Entity();
        
        // Set ETag
        $etag = $result-&gt;attributes($this-&gt;_dataServicesMetadataNamespaceName);
        $etag = $etag[Resources::ETAG];
        $entity-&gt;setETag((string)$etag);
        
        foreach ($prop as $key =&gt; $value) {
            $attributes = $value-&gt;attributes(
                $this-&gt;_dataServicesMetadataNamespaceName
            );
            $type       = $attributes['type'];
            $isnull     = $attributes['null'];
            $value      = EdmType::unserializeQueryValue((string)$type, $value);
            
            $entity-&gt;addProperty(
                (string)$key,
                is_null($type) ? EdmType::STRING : (string)$type,
                $isnull ? null : $value
            );
        }
        
        return $entity;
    }
    
    /**
     * Constructs new AtomReaderWriter object.
     */
    public function __construct()
    {
        $this-&gt;_atomNamespaceName                 = Resources::ATOM_XML_NAMESPACE;
        $this-&gt;_dataServicesNamespaceName         = Resources::DS_XML_NAMESPACE;
        $this-&gt;_dataServicesMetadataNamespaceName = Resources::DSM_XML_NAMESPACE;
        $this-&gt;_dataServicesPrefix                = 'd';
        $this-&gt;_dataServicesMetadataPrefix        = 'm';
        $this-&gt;_xmlVersion                        = '1.0';
        $this-&gt;_xmlEncoding                       = 'UTF-8';
    }
    
    /**
     * Constructs XML representation for table entry.
     *
     * @param string $name The name of the table.
     *
     * @return string
     */
    public function getTable($name)
    {
        return $this-&gt;_serializeAtom(array('TableName' =&gt; array($name =&gt; null)));
    }
    
    /**
     * Parses one table entry.
     *
     * @param string $body The HTTP response body.
     *
     * @return string
     */
    public function parseTable($body)
    {
        $result = $this-&gt;_parseBody($body);
        return $this-&gt;_parseOneTable($result);
    }
    
    /**
     * Constructs array of tables from HTTP response body.
     *
     * @param string $body The HTTP response body.
     *
     * @return array
     */
    public function parseTableEntries($body)
    {
        $tables     = array();
        $result     = $this-&gt;_parseBody($body);
        $rawEntries = $this-&gt;_getRawEntries($result);
        
        foreach ($rawEntries as $entry) {
            $tables[] = $this-&gt;_parseOneTable($entry);
        }
        
        return $tables;
    }
    
    /**
     * Constructs XML representation for entity.
     *
     * @param Entity $entity The entity instance.
     *
     * @return string
     */
    public function getEntity(Entity $entity)
    {
        $entityProperties = $entity-&gt;getProperties();
        $properties       = array();
        
        foreach ($entityProperties as $name =&gt; $property) {
            $attributes = array();
            $edmType    = $property-&gt;getEdmType();
            $edmValue   = $property-&gt;getValue();
            if (!is_null($edmType)) {
                $attributes['type'] = $edmType;
            }
            if (is_null($edmValue)) {
                $attributes['null'] = 'true';
            }
            $value             = EdmType::serializeValue($edmType, $edmValue);
            $properties[$name] = array($value =&gt; $attributes);
        }
        
        return $this-&gt;_serializeAtom($properties);
    }
    
    /**
     * Constructs entity from HTTP response body.
     *
     * @param string $body The HTTP response body.
     *
     * @return Entity
     */
    public function parseEntity($body)
    {
        $result = $this-&gt;_parseBody($body);
        $entity = $this-&gt;_parseOneEntity($result);
        return $entity;
    }
    
    /**
     * Constructs array of entities from HTTP response body.
     *
     * @param string $body The HTTP response body.
     *
     * @return array
     */
    public function parseEntities($body)
    {
        $result     = $this-&gt;_parseBody($body);
        $entities   = array();
        $rawEntries = $this-&gt;_getRawEntries($result);
        
        foreach ($rawEntries as $entity) {
            $entities[] = $this-&gt;_parseOneEntity($entity);
        }
        
        return $entities;
    }
}
</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all();
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>