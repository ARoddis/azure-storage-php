<html>
    <head>
        <script
            type="text/javascript"
            src="../../js/jquery-1.4.2.min.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shCore.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shBrushJScript.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shBrushPhp.js">
        </script>
        <script
            type="text/javascript"
            src="../../syntax_highlighter/scripts/shBrushXml.js">
        </script>
        <link
            href="../../syntax_highlighter/styles/shCore.css" rel="stylesheet"
            type="text/css"
        />
        <link
            href="../../syntax_highlighter/styles/shCoreEclipse.css"
            rel="stylesheet" type="text/css"
        />
        <link
            href="../../syntax_highlighter/styles/shThemeWordpress.css"
            rel="stylesheet" type="text/css"
        />
    </head>
    <body>
        <pre class="brush: php">&lt;?php

/**
 * LICENSE: The MIT License (the &quot;License&quot;)
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * https://github.com/azure/azure-storage-php/LICENSE
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * PHP version 5
 *
 * @category  Microsoft
 * @package   MicrosoftAzure\Storage\Table
 * @author    Azure Storage PHP SDK &lt;dmsh@microsoft.com&gt;
 * @copyright 2016 Microsoft Corporation
 * @license   https://github.com/azure/azure-storage-php/LICENSE
 * @link      https://github.com/azure/azure-storage-php
 */

namespace MicrosoftAzure\Storage\Table;

use MicrosoftAzure\Storage\Common\Internal\ServiceRestTrait;
use MicrosoftAzure\Storage\Common\Internal\Resources;
use MicrosoftAzure\Storage\Common\Internal\Utilities;
use MicrosoftAzure\Storage\Common\Internal\Validate;
use MicrosoftAzure\Storage\Common\Internal\Http\HttpCallContext;
use MicrosoftAzure\Storage\Common\Internal\ServiceRestProxy;
use MicrosoftAzure\Storage\Common\LocationMode;
use MicrosoftAzure\Storage\Table\Internal\ITable;
use MicrosoftAzure\Storage\Table\Models\TableServiceOptions;
use MicrosoftAzure\Storage\Table\Models\EdmType;
use MicrosoftAzure\Storage\Table\Models\Filters;
use MicrosoftAzure\Storage\Table\Models\Filters\Filter;
use MicrosoftAzure\Storage\Table\Models\Filters\PropertyNameFilter;
use MicrosoftAzure\Storage\Table\Models\Filters\ConstantFilter;
use MicrosoftAzure\Storage\Table\Models\Filters\UnaryFilter;
use MicrosoftAzure\Storage\Table\Models\Filters\BinaryFilter;
use MicrosoftAzure\Storage\Table\Models\Filters\QueryStringFilter;
use MicrosoftAzure\Storage\Table\Models\GetTableResult;
use MicrosoftAzure\Storage\Table\Models\QueryTablesOptions;
use MicrosoftAzure\Storage\Table\Models\QueryTablesResult;
use MicrosoftAzure\Storage\Table\Models\InsertEntityResult;
use MicrosoftAzure\Storage\Table\Models\UpdateEntityResult;
use MicrosoftAzure\Storage\Table\Models\QueryEntitiesOptions;
use MicrosoftAzure\Storage\Table\Models\QueryEntitiesResult;
use MicrosoftAzure\Storage\Table\Models\DeleteEntityOptions;
use MicrosoftAzure\Storage\Table\Models\GetEntityResult;
use MicrosoftAzure\Storage\Table\Models\BatchOperationType;
use MicrosoftAzure\Storage\Table\Models\BatchOperationParameterName;
use MicrosoftAzure\Storage\Table\Models\BatchResult;
use MicrosoftAzure\Storage\Table\Models\TableACL;
use MicrosoftAzure\Storage\Common\Internal\Http\HttpFormatter;
use MicrosoftAzure\Storage\Table\Internal\IAtomReaderWriter;
use MicrosoftAzure\Storage\Table\Internal\IMimeReaderWriter;
use MicrosoftAzure\Storage\Common\Internal\Serialization\ISerializer;

/**
 * This class constructs HTTP requests and receive HTTP responses for table
 * service layer.
 *
 * @category  Microsoft
 * @package   MicrosoftAzure\Storage\Table
 * @author    Azure Storage PHP SDK &lt;dmsh@microsoft.com&gt;
 * @copyright 2016 Microsoft Corporation
 * @license   https://github.com/azure/azure-storage-php/LICENSE
 * @link      https://github.com/azure/azure-storage-php
 */
class TableRestProxy extends ServiceRestProxy implements ITable
{
    use ServiceRestTrait;

    /**
     * @var Internal\IAtomReaderWriter
     */
    private $_atomSerializer;

    /**
     *
     * @var Internal\IMimeReaderWriter
     */
    private $_mimeSerializer;

    /**
     * Creates contexts for batch operations.
     *
     * @param array $operations The batch operations array.
     *
     * @return array
     *
     * @throws \InvalidArgumentException
     */
    private function _createOperationsContexts(array $operations)
    {
        $contexts = array();

        foreach ($operations as $operation) {
            $context = null;
            $type    = $operation-&gt;getType();

            switch ($type) {
                case BatchOperationType::INSERT_ENTITY_OPERATION:
                case BatchOperationType::UPDATE_ENTITY_OPERATION:
                case BatchOperationType::MERGE_ENTITY_OPERATION:
                case BatchOperationType::INSERT_REPLACE_ENTITY_OPERATION:
                case BatchOperationType::INSERT_MERGE_ENTITY_OPERATION:
                    $table   = $operation-&gt;getParameter(
                        BatchOperationParameterName::BP_TABLE
                    );
                    $entity  = $operation-&gt;getParameter(
                        BatchOperationParameterName::BP_ENTITY
                    );
                    $context = $this-&gt;_getOperationContext($table, $entity, $type);
                    break;
    
                case BatchOperationType::DELETE_ENTITY_OPERATION:
                    $table        = $operation-&gt;getParameter(
                        BatchOperationParameterName::BP_TABLE
                    );
                    $partitionKey = $operation-&gt;getParameter(
                        BatchOperationParameterName::BP_PARTITION_KEY
                    );
                    $rowKey       = $operation-&gt;getParameter(
                        BatchOperationParameterName::BP_ROW_KEY
                    );
                    $etag         = $operation-&gt;getParameter(
                        BatchOperationParameterName::BP_ETAG
                    );
                    $options      = new DeleteEntityOptions();
                    $options-&gt;setETag($etag);
                    $context = $this-&gt;_constructDeleteEntityContext(
                        $table,
                        $partitionKey,
                        $rowKey,
                        $options
                    );
                    break;
    
                default:
                    throw new \InvalidArgumentException();
            }

            $contexts[] = $context;
        }

        return $contexts;
    }

    /**
     * Creates operation context for the API.
     *
     * @param string        $table  The table name.
     * @param Models\Entity $entity The entity object.
     * @param string        $type   The API type.
     *
     * @return \MicrosoftAzure\Storage\Common\Internal\Http\HttpCallContext
     *
     * @throws \InvalidArgumentException
     */
    private function _getOperationContext($table, Models\Entity $entity, $type)
    {
        switch ($type) {
            case BatchOperationType::INSERT_ENTITY_OPERATION:
                return $this-&gt;_constructInsertEntityContext($table, $entity, null);
    
            case BatchOperationType::UPDATE_ENTITY_OPERATION:
                return $this-&gt;_constructPutOrMergeEntityContext(
                    $table,
                    $entity,
                    Resources::HTTP_PUT,
                    true,
                    null
                );
    
            case BatchOperationType::MERGE_ENTITY_OPERATION:
                return $this-&gt;_constructPutOrMergeEntityContext(
                    $table,
                    $entity,
                    Resources::HTTP_MERGE,
                    true,
                    null
                );
    
            case BatchOperationType::INSERT_REPLACE_ENTITY_OPERATION:
                return $this-&gt;_constructPutOrMergeEntityContext(
                    $table,
                    $entity,
                    Resources::HTTP_PUT,
                    false,
                    null
                );
    
            case BatchOperationType::INSERT_MERGE_ENTITY_OPERATION:
                return $this-&gt;_constructPutOrMergeEntityContext(
                    $table,
                    $entity,
                    Resources::HTTP_MERGE,
                    false,
                    null
                );
    
            default:
                throw new \InvalidArgumentException();
        }
    }

    /**
     * Creates MIME part body for batch API.
     *
     * @param array $operations The batch operations.
     * @param array $contexts   The contexts objects.
     *
     * @return array
     *
     * @throws \InvalidArgumentException
     */
    private function _createBatchRequestBody(array $operations, array $contexts)
    {
        $mimeBodyParts = array();
        $contentId     = 1;
        $count         = count($operations);

        Validate::isTrue(
            count($operations) == count($contexts),
            Resources::INVALID_OC_COUNT_MSG
        );

        for ($i = 0; $i &lt; $count; $i++) {
            $operation = $operations[$i];
            $context   = $contexts[$i];
            $type      = $operation-&gt;getType();

            switch ($type) {
                case BatchOperationType::INSERT_ENTITY_OPERATION:
                case BatchOperationType::UPDATE_ENTITY_OPERATION:
                case BatchOperationType::MERGE_ENTITY_OPERATION:
                case BatchOperationType::INSERT_REPLACE_ENTITY_OPERATION:
                case BatchOperationType::INSERT_MERGE_ENTITY_OPERATION:
                    $contentType  = $context-&gt;getHeader(Resources::CONTENT_TYPE);
                    $body         = $context-&gt;getBody();
                    $contentType .= ';type=entry';
                    $context-&gt;addOptionalHeader(Resources::CONTENT_TYPE, $contentType);
                    // Use mb_strlen instead of strlen to get the length of the string
                    // in bytes instead of the length in chars.
                    $context-&gt;addOptionalHeader(
                        Resources::CONTENT_LENGTH,
                        strlen($body)
                    );
                    break;
    
                case BatchOperationType::DELETE_ENTITY_OPERATION:
                    break;
    
                default:
                    throw new \InvalidArgumentException();
            }

            $context-&gt;addOptionalHeader(Resources::CONTENT_ID, $contentId);
            $mimeBodyPart    = $context-&gt;__toString();
            $mimeBodyParts[] = $mimeBodyPart;
            $contentId++;
        }

        return $this-&gt;_mimeSerializer-&gt;encodeMimeMultipart($mimeBodyParts);
    }

    /**
     * Constructs HTTP call context for deleteEntity API.
     *
     * @param string                     $table        The name of the table.
     * @param string                     $partitionKey The entity partition key.
     * @param string                     $rowKey       The entity row key.
     * @param Models\DeleteEntityOptions $options      The optional parameters.
     *
     * @return HttpCallContext
     */
    private function _constructDeleteEntityContext(
        $table,
        $partitionKey,
        $rowKey,
        Models\DeleteEntityOptions $options = null
    ) {
        Validate::isString($table, 'table');
        Validate::notNullOrEmpty($table, 'table');
        Validate::isTrue(!is_null($partitionKey), Resources::NULL_TABLE_KEY_MSG);
        Validate::isTrue(!is_null($rowKey), Resources::NULL_TABLE_KEY_MSG);

        $method      = Resources::HTTP_DELETE;
        $headers     = array();
        $queryParams = array();
        $statusCode  = Resources::STATUS_NO_CONTENT;
        $path        = $this-&gt;_getEntityPath($table, $partitionKey, $rowKey);

        if (is_null($options)) {
            $options = new DeleteEntityOptions();
        }

        $etagObj = $options-&gt;getETag();
        $ETag    = !is_null($etagObj);
        $this-&gt;addOptionalHeader(
            $headers,
            Resources::IF_MATCH,
            $ETag ? $etagObj : Resources::ASTERISK
        );

        $options-&gt;setLocationMode(LocationMode::PRIMARY_ONLY);

        $context = new HttpCallContext();
        $context-&gt;setHeaders($headers);
        $context-&gt;setMethod($method);
        $context-&gt;setPath($path);
        $context-&gt;setQueryParameters($queryParams);
        $context-&gt;addStatusCode($statusCode);
        $context-&gt;setBody('');
        $context-&gt;setServiceOptions($options);

        return $context;
    }

    /**
     * Constructs HTTP call context for updateEntity, mergeEntity,
     * insertOrReplaceEntity and insertOrMergeEntity.
     *
     * @param string                     $table   The table name.
     * @param Models\Entity              $entity  The entity instance to use.
     * @param string                     $verb    The HTTP method.
     * @param boolean                    $useETag The flag to include etag or not.
     * @param Models\TableServiceOptions $options The optional parameters.
     *
     * @return HttpCallContext
     */
    private function _constructPutOrMergeEntityContext(
        $table,
        Models\Entity $entity,
        $verb,
        $useETag,
        Models\TableServiceOptions $options = null
    ) {
        Validate::isString($table, 'table');
        Validate::notNullOrEmpty($table, 'table');
        Validate::notNullOrEmpty($entity, 'entity');
        Validate::isTrue($entity-&gt;isValid($msg), $msg);

        $method       = $verb;
        $headers      = array();
        $queryParams  = array();
        $statusCode   = Resources::STATUS_NO_CONTENT;
        $partitionKey = $entity-&gt;getPartitionKey();
        $rowKey       = $entity-&gt;getRowKey();
        $path         = $this-&gt;_getEntityPath($table, $partitionKey, $rowKey);
        $body         = $this-&gt;_atomSerializer-&gt;getEntity($entity);

        if (is_null($options)) {
            $options = new TableServiceOptions();
        }

        if ($useETag) {
            $etag         = $entity-&gt;getETag();
            $ifMatchValue = is_null($etag) ? Resources::ASTERISK : $etag;

            $this-&gt;addOptionalHeader($headers, Resources::IF_MATCH, $ifMatchValue);
        }

        $this-&gt;addOptionalHeader(
            $headers,
            Resources::CONTENT_TYPE,
            Resources::XML_ATOM_CONTENT_TYPE
        );

        $options-&gt;setLocationMode(LocationMode::PRIMARY_ONLY);
        $context = new HttpCallContext();
        $context-&gt;setBody($body);
        $context-&gt;setHeaders($headers);
        $context-&gt;setMethod($method);
        $context-&gt;setPath($path);
        $context-&gt;setQueryParameters($queryParams);
        $context-&gt;addStatusCode($statusCode);
        $context-&gt;setServiceOptions($options);

        return $context;
    }

    /**
     * Constructs HTTP call context for insertEntity API.
     *
     * @param string                     $table   The name of the table.
     * @param Models\Entity              $entity  The table entity.
     * @param Models\TableServiceOptions $options The optional parameters.
     *
     * @return HttpCallContext
     */
    private function _constructInsertEntityContext(
        $table,
        Models\Entity $entity,
        Models\TableServiceOptions $options = null
    ) {
        Validate::isString($table, 'table');
        Validate::notNullOrEmpty($table, 'table');
        Validate::notNullOrEmpty($entity, 'entity');
        Validate::isTrue($entity-&gt;isValid($msg), $msg);

        $method      = Resources::HTTP_POST;
        $context     = new HttpCallContext();
        $headers     = array();
        $queryParams = array();
        $statusCode  = Resources::STATUS_CREATED;
        $path        = $table;
        $body        = $this-&gt;_atomSerializer-&gt;getEntity($entity);

        if (is_null($options)) {
            $options = new TableServiceOptions();
        }

        $this-&gt;addOptionalHeader(
            $headers,
            Resources::CONTENT_TYPE,
            Resources::XML_ATOM_CONTENT_TYPE
        );

        $options-&gt;setLocationMode(LocationMode::PRIMARY_ONLY);
        $context-&gt;setBody($body);
        $context-&gt;setHeaders($headers);
        $context-&gt;setMethod($method);
        $context-&gt;setPath($path);
        $context-&gt;setQueryParameters($queryParams);
        $context-&gt;addStatusCode($statusCode);
        $context-&gt;setServiceOptions($options);

        return $context;
    }

    /**
     * Constructs URI path for entity.
     *
     * @param string $table        The table name.
     * @param string $partitionKey The entity's partition key.
     * @param string $rowKey       The entity's row key.
     *
     * @return string
     */
    private function _getEntityPath($table, $partitionKey, $rowKey)
    {
        $encodedPK = $this-&gt;_encodeODataUriValue($partitionKey);
        $encodedRK = $this-&gt;_encodeODataUriValue($rowKey);

        return &quot;$table(PartitionKey='$encodedPK',RowKey='$encodedRK')&quot;;
    }

    /**
     * Creates a promie that does the actual work for update and merge entity
     * APIs.
     *
     * @param string                     $table   The table name.
     * @param Models\Entity              $entity  The entity instance to use.
     * @param string                     $verb    The HTTP method.
     * @param boolean                    $useETag The flag to include etag or not.
     * @param Models\TableServiceOptions $options The optional parameters.
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    private function _putOrMergeEntityAsyncImpl(
        $table,
        Models\Entity $entity,
        $verb,
        $useETag,
        Models\TableServiceOptions $options = null
    ) {
        $context = $this-&gt;_constructPutOrMergeEntityContext(
            $table,
            $entity,
            $verb,
            $useETag,
            $options
        );

        return $this-&gt;sendContextAsync($context)-&gt;then(function ($response) {
            return UpdateEntityResult::create(
                HttpFormatter::formatHeaders($response-&gt;getHeaders())
            );
        }, null);
    }

    /**
     * Builds filter expression
     *
     * @param Filter $filter The filter object
     *
     * @return string
     */
    private function _buildFilterExpression(Filter $filter)
    {
        $e = Resources::EMPTY_STRING;
        $this-&gt;_buildFilterExpressionRec($filter, $e);

        return $e;
    }

    /**
     * Builds filter expression
     *
     * @param Filter $filter The filter object
     * @param string &amp;$e     The filter expression
     *
     * @return string
     */
    private function _buildFilterExpressionRec(Filter $filter, &amp;$e)
    {
        if (is_null($filter)) {
            return;
        }

        if ($filter instanceof PropertyNameFilter) {
            $e .= $filter-&gt;getPropertyName();
        } elseif ($filter instanceof ConstantFilter) {
            $value = $filter-&gt;getValue();
            // If the value is null we just append null regardless of the edmType.
            if (is_null($value)) {
                $e .= 'null';
            } else {
                $type = $filter-&gt;getEdmType();
                $e   .= EdmType::serializeQueryValue($type, $value);
            }
        } elseif ($filter instanceof UnaryFilter) {
            $e .= $filter-&gt;getOperator();
            $e .= '(';
            $this-&gt;_buildFilterExpressionRec($filter-&gt;getOperand(), $e);
            $e .= ')';
        } elseif ($filter instanceof Filters\BinaryFilter) {
            $e .= '(';
            $this-&gt;_buildFilterExpressionRec($filter-&gt;getLeft(), $e);
            $e .= ' ';
            $e .= $filter-&gt;getOperator();
            $e .= ' ';
            $this-&gt;_buildFilterExpressionRec($filter-&gt;getRight(), $e);
            $e .= ')';
        } elseif ($filter instanceof QueryStringFilter) {
            $e .= $filter-&gt;getQueryString();
        }

        return $e;
    }

    /**
     * Adds query object to the query parameter array
     *
     * @param array        $queryParam The URI query parameters
     * @param Models\Query $query      The query object
     *
     * @return array
     */
    private function _addOptionalQuery(array $queryParam, Models\Query $query)
    {
        if (!is_null($query)) {
            $selectedFields = $query-&gt;getSelectFields();
            if (!empty($selectedFields)) {
                $final = $this-&gt;_encodeODataUriValues($selectedFields);

                $this-&gt;addOptionalQueryParam(
                    $queryParam,
                    Resources::QP_SELECT,
                    implode(',', $final)
                );
            }

            if (!is_null($query-&gt;getTop())) {
                $final = strval($this-&gt;_encodeODataUriValue($query-&gt;getTop()));

                $this-&gt;addOptionalQueryParam(
                    $queryParam,
                    Resources::QP_TOP,
                    $final
                );
            }

            if (!is_null($query-&gt;getFilter())) {
                $final = $this-&gt;_buildFilterExpression($query-&gt;getFilter());
                $this-&gt;addOptionalQueryParam(
                    $queryParam,
                    Resources::QP_FILTER,
                    $final
                );
            }
        }

        return $queryParam;
    }

    /**
     * Encodes OData URI values
     *
     * @param array $values The OData URL values
     *
     * @return array
     */
    private function _encodeODataUriValues(array $values)
    {
        $list = array();

        foreach ($values as $value) {
            $list[] = $this-&gt;_encodeODataUriValue($value);
        }

        return $list;
    }

    /**
     * Encodes OData URI value
     *
     * @param string $value The OData URL value
     *
     * @return string
     */
    private function _encodeODataUriValue($value)
    {
        // Replace each single quote (') with double single quotes ('') not doudle
        // quotes (&quot;)
        $value = str_replace('\'', '\'\'', $value);

        // Encode the special URL characters
        $value = rawurlencode($value);

        return $value;
    }

    /**
     * Initializes new TableRestProxy object.
     *
     * @param string            $primaryUri     The storage account primary uri.
     * @param string            $secondaryUri   The storage account secondary uri.
     * @param IAtomReaderWriter $atomSerializer The atom serializer.
     * @param IMimeReaderWriter $mimeSerializer The MIME serializer.
     * @param ISerializer       $dataSerializer The data serializer.
     * @param array             $options        Array of options to pass to the service
     */
    public function __construct(
        $primaryUri,
        $secondaryUri,
        IAtomReaderWriter $atomSerializer,
        IMimeReaderWriter $mimeSerializer,
        ISerializer $dataSerializer,
        array $options = []
    ) {
        parent::__construct(
            $primaryUri,
            $secondaryUri,
            Resources::EMPTY_STRING,
            $dataSerializer,
            $options
        );
        $this-&gt;_atomSerializer = $atomSerializer;
        $this-&gt;_mimeSerializer = $mimeSerializer;
    }

    /**
     * Quries tables in the given storage account.
     *
     * @param Models\QueryTablesOptions|string|Models\Filters\Filter $options Could be
     * optional parameters, table prefix or filter to apply.
     *
     * @return Models\QueryTablesResult
     *
     * @see http://msdn.microsoft.com/en-us/library/windowsazure/dd179405.aspx
     */
    public function queryTables($options = null)
    {
        return $this-&gt;queryTablesAsync($options)-&gt;wait();
    }

    /**
     * Creates promise to query the tables in the given storage account.
     *
     * @param Models\QueryTablesOptions|string|Models\Filters\Filter $options Could be
     * optional parameters, table prefix or filter to apply.
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     *
     * @see http://msdn.microsoft.com/en-us/library/windowsazure/dd179405.aspx
     */
    public function queryTablesAsync($options = null)
    {
        $method      = Resources::HTTP_GET;
        $headers     = array();
        $postParams  = array();
        $queryParams = array();
        $path        = 'Tables';

        if (is_null($options)) {
            $options = new QueryTablesOptions();
        } elseif (is_string($options)) {
            $prefix  = $options;
            $options = new QueryTablesOptions();
            $options-&gt;setPrefix($prefix);
        } elseif ($options instanceof Filter) {
            $filter  = $options;
            $options = new QueryTablesOptions();
            $options-&gt;setFilter($filter);
        }

        $query   = $options-&gt;getQuery();
        $next    = $options-&gt;getNextTableName();
        $prefix  = $options-&gt;getPrefix();

        if (!empty($prefix)) {
            // Append Max char to end '{' is 1 + 'z' in AsciiTable ==&gt; upperBound
            // is prefix + '{'
            $prefixFilter = Filter::applyAnd(
                Filter::applyGe(
                    Filter::applyPropertyName('TableName'),
                    Filter::applyConstant($prefix, EdmType::STRING)
                ),
                Filter::applyLe(
                    Filter::applyPropertyName('TableName'),
                    Filter::applyConstant($prefix . '{', EdmType::STRING)
                )
            );

            if (is_null($query)) {
                $query = new Models\Query();
            }

            if (is_null($query-&gt;getFilter())) {
                // use the prefix filter if the query filter is null
                $query-&gt;setFilter($prefixFilter);
            } else {
                // combine and use the prefix filter if the query filter exists
                $combinedFilter = Filter::applyAnd(
                    $query-&gt;getFilter(),
                    $prefixFilter
                );
                $query-&gt;setFilter($combinedFilter);
            }
        }

        $queryParams = $this-&gt;_addOptionalQuery($queryParams, $query);

        $this-&gt;addOptionalQueryParam(
            $queryParams,
            Resources::QP_NEXT_TABLE_NAME,
            $next
        );

        // One can specify the NextTableName option to get table entities starting
        // from the specified name. However, there appears to be an issue in the
        // Azure Table service where this does not engage on the server unless
        // $filter appears in the URL. The current behavior is to just ignore the
        // NextTableName options, which is not expected or easily detectable.
        if (array_key_exists(Resources::QP_NEXT_TABLE_NAME, $queryParams)
            &amp;&amp; !array_key_exists(Resources::QP_FILTER, $queryParams)
        ) {
            $queryParams[Resources::QP_FILTER] = Resources::EMPTY_STRING;
        }

        $atomSerializer = $this-&gt;_atomSerializer;

        return $this-&gt;sendAsync(
            $method,
            $headers,
            $queryParams,
            $postParams,
            $path,
            Resources::STATUS_OK,
            Resources::EMPTY_STRING,
            $options
        )-&gt;then(function ($response) use ($atomSerializer) {
            $tables = $atomSerializer-&gt;parseTableEntries($response-&gt;getBody());
            return QueryTablesResult::create(
                HttpFormatter::formatHeaders($response-&gt;getHeaders()),
                $tables
            );
        }, null);
    }

    /**
     * Creates new table in the storage account
     *
     * @param string                     $table   The name of the table.
     * @param Models\TableServiceOptions $options The optional parameters.
     *
     * @return void
     *
     * @see http://msdn.microsoft.com/en-us/library/windowsazure/dd135729.aspx
     */
    public function createTable($table, Models\TableServiceOptions $options = null)
    {
        $this-&gt;createTableAsync($table, $options)-&gt;wait();
    }

    /**
     * Creates promise to create new table in the storage account
     *
     * @param string                     $table   The name of the table.
     * @param Models\TableServiceOptions $options The optional parameters.
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     *
     * @see http://msdn.microsoft.com/en-us/library/windowsazure/dd135729.aspx
     */
    public function createTableAsync(
        $table,
        Models\TableServiceOptions $options = null
    ) {
        Validate::isString($table, 'table');
        Validate::notNullOrEmpty($table, 'table');

        $method      = Resources::HTTP_POST;
        $headers     = array();
        $postParams  = array();
        $queryParams = array();
        $path        = 'Tables';
        $body        = $this-&gt;_atomSerializer-&gt;getTable($table);

        if (is_null($options)) {
            $options = new TableServiceOptions();
        }

        $this-&gt;addOptionalHeader(
            $headers,
            Resources::CONTENT_TYPE,
            Resources::XML_ATOM_CONTENT_TYPE
        );

        $options-&gt;setLocationMode(LocationMode::PRIMARY_ONLY);

        return $this-&gt;sendAsync(
            $method,
            $headers,
            $queryParams,
            $postParams,
            $path,
            Resources::STATUS_CREATED,
            $body,
            $options
        );
    }

    /**
     * Gets the table.
     *
     * @param string                     $table   The name of the table.
     * @param Models\TableServiceOptions $options The optional parameters.
     *
     * @return Models\GetTableResult
     */
    public function getTable($table, Models\TableServiceOptions $options = null)
    {
        return $this-&gt;getTableAsync($table, $options)-&gt;wait();
    }

    /**
     * Creates the promise to get the table.
     *
     * @param string                     $table   The name of the table.
     * @param Models\TableServiceOptions $options The optional parameters.
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTableAsync(
        $table,
        Models\TableServiceOptions $options = null
    ) {
        Validate::isString($table, 'table');
        Validate::notNullOrEmpty($table, 'table');

        $method      = Resources::HTTP_GET;
        $headers     = array();
        $postParams  = array();
        $queryParams = array();
        $path        = &quot;Tables('$table')&quot;;

        if (is_null($options)) {
            $options = new TableServiceOptions();
        }

        $this-&gt;addOptionalHeader(
            $headers,
            Resources::CONTENT_TYPE,
            Resources::XML_ATOM_CONTENT_TYPE
        );

        $atomSerializer = $this-&gt;_atomSerializer;

        return $this-&gt;sendAsync(
            $method,
            $headers,
            $queryParams,
            $postParams,
            $path,
            Resources::STATUS_OK,
            Resources::EMPTY_STRING,
            $options
        )-&gt;then(function ($response) use ($atomSerializer) {
            return GetTableResult::create($response-&gt;getBody(), $atomSerializer);
        }, null);
    }

    /**
     * Deletes the specified table and any data it contains.
     *
     * @param string                     $table   The name of the table.
     * @param Models\TableServiceOptions $options optional parameters
     *
     * @return void
     *
     * @see http://msdn.microsoft.com/en-us/library/windowsazure/dd179387.aspx
     */
    public function deleteTable($table, Models\TableServiceOptions$options = null)
    {
        $this-&gt;deleteTableAsync($table, $options)-&gt;wait();
    }

    /**
     * Creates promise to delete the specified table and any data it contains.
     *
     * @param string                     $table   The name of the table.
     * @param Models\TableServiceOptions $options optional parameters
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     *
     * @see http://msdn.microsoft.com/en-us/library/windowsazure/dd179387.aspx
     */
    public function deleteTableAsync(
        $table,
        Models\TableServiceOptions$options = null
    ) {
        Validate::isString($table, 'table');
        Validate::notNullOrEmpty($table, 'table');

        $method      = Resources::HTTP_DELETE;
        $headers     = array();
        $postParams  = array();
        $queryParams = array();
        $path        = &quot;Tables('$table')&quot;;

        if (is_null($options)) {
            $options = new TableServiceOptions();
        }

        return $this-&gt;sendAsync(
            $method,
            $headers,
            $queryParams,
            $postParams,
            $path,
            Resources::STATUS_NO_CONTENT,
            Resources::EMPTY_STRING,
            $options
        );
    }

    /**
     * Quries entities for the given table name
     *
     * @param string                                                   $table   The name of
     * the table.
     * @param Models\QueryEntitiesOptions|string|Models\Filters\Filter $options Coule be
     * optional parameters, query string or filter to apply.
     *
     * @return Models\QueryEntitiesResult
     *
     * @see http://msdn.microsoft.com/en-us/library/windowsazure/dd179421.aspx
     */
    public function queryEntities($table, $options = null)
    {
        return $this-&gt;queryEntitiesAsync($table, $options)-&gt;wait();
    }

    /**
     * Quries entities for the given table name
     *
     * @param string                                                   $table   The name of
     * the table.
     * @param Models\QueryEntitiesOptions|string|Models\Filters\Filter $options Coule be
     * optional parameters, query string or filter to apply.
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     *
     * @see http://msdn.microsoft.com/en-us/library/windowsazure/dd179421.aspx
     */
    public function queryEntitiesAsync($table, $options = null)
    {
        Validate::isString($table, 'table');
        Validate::notNullOrEmpty($table, 'table');

        $method      = Resources::HTTP_GET;
        $headers     = array();
        $postParams  = array();
        $queryParams = array();
        $path        = $table;

        if (is_null($options)) {
            $options = new QueryEntitiesOptions();
        } elseif (is_string($options)) {
            $queryString = $options;
            $options     = new QueryEntitiesOptions();
            $options-&gt;setFilter(Filter::applyQueryString($queryString));
        } elseif ($options instanceof Filter) {
            $filter  = $options;
            $options = new QueryEntitiesOptions();
            $options-&gt;setFilter($filter);
        }

        $queryParams = $this-&gt;_addOptionalQuery($queryParams, $options-&gt;getQuery());

        $this-&gt;addOptionalQueryParam(
            $queryParams,
            Resources::QP_NEXT_PK,
            $options-&gt;getNextPartitionKey()
        );
        $this-&gt;addOptionalQueryParam(
            $queryParams,
            Resources::QP_NEXT_RK,
            $options-&gt;getNextRowKey()
        );

        $this-&gt;addOptionalHeader(
            $headers,
            Resources::CONTENT_TYPE,
            Resources::XML_ATOM_CONTENT_TYPE
        );

        if (!is_null($options-&gt;getQuery())) {
            $dsHeader   = Resources::DATA_SERVICE_VERSION;
            $maxdsValue = Resources::MAX_DATA_SERVICE_VERSION_VALUE;
            $fields     = $options-&gt;getQuery()-&gt;getSelectFields();
            $hasSelect  = !empty($fields);
            if ($hasSelect) {
                $this-&gt;addOptionalHeader($headers, $dsHeader, $maxdsValue);
            }
        }

        $atomSerializer = $this-&gt;_atomSerializer;

        return $this-&gt;sendAsync(
            $method,
            $headers,
            $queryParams,
            $postParams,
            $path,
            Resources::STATUS_OK,
            Resources::EMPTY_STRING,
            $options
        )-&gt;then(function ($response) use ($atomSerializer) {
            $entities = $atomSerializer-&gt;parseEntities($response-&gt;getBody());

            return QueryEntitiesResult::create(
                HttpFormatter::formatHeaders($response-&gt;getHeaders()),
                $entities
            );
        }, null);
    }

    /**
     * Inserts new entity to the table.
     *
     * @param string                     $table   name of the table.
     * @param Models\Entity              $entity  table entity.
     * @param Models\TableServiceOptions $options optional parameters.
     *
     * @return Models\InsertEntityResult
     *
     * @see http://msdn.microsoft.com/en-us/library/windowsazure/dd179433.aspx
     */
    public function insertEntity(
        $table,
        Models\Entity $entity,
        Models\TableServiceOptions $options = null
    ) {
        return $this-&gt;insertEntityAsync($table, $entity, $options)-&gt;wait();
    }

    /**
     * Inserts new entity to the table.
     *
     * @param string                     $table   name of the table.
     * @param Models\Entity              $entity  table entity.
     * @param Models\TableServiceOptions $options optional parameters.
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     *
     * @see http://msdn.microsoft.com/en-us/library/windowsazure/dd179433.aspx
     */
    public function insertEntityAsync(
        $table,
        Models\Entity $entity,
        Models\TableServiceOptions $options = null
    ) {
        $context = $this-&gt;_constructInsertEntityContext(
            $table,
            $entity,
            $options
        );

        $atomSerializer = $this-&gt;_atomSerializer;

        return $this-&gt;sendContextAsync($context)-&gt;then(
            function ($response) use ($atomSerializer) {
                $body     = $response-&gt;getBody();
                $headers  = HttpFormatter::formatHeaders($response-&gt;getHeaders());
                return InsertEntityResult::create(
                    $body,
                    $headers,
                    $atomSerializer
                );
            },
            null
        );
    }

    /**
     * Updates an existing entity or inserts a new entity if it does not exist
     * in the table.
     *
     * @param string                     $table   name of the table
     * @param Models\Entity              $entity  table entity
     * @param Models\TableServiceOptions $options optional parameters
     *
     * @return Models\UpdateEntityResult
     *
     * @see http://msdn.microsoft.com/en-us/library/windowsazure/hh452241.aspx
     */
    public function insertOrMergeEntity(
        $table,
        Models\Entity $entity,
        Models\TableServiceOptions $options = null
    ) {
        return $this-&gt;insertOrMergeEntityAsync($table, $entity, $options)-&gt;wait();
    }

    /**
     * Creates promise to update an existing entity or inserts a new entity if
     * it does not exist in the table.
     *
     * @param string                     $table   name of the table
     * @param Models\Entity              $entity  table entity
     * @param Models\TableServiceOptions $options optional parameters
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     *
     * @see http://msdn.microsoft.com/en-us/library/windowsazure/hh452241.aspx
     */
    public function insertOrMergeEntityAsync(
        $table,
        Models\Entity $entity,
        Models\TableServiceOptions $options = null
    ) {
        return $this-&gt;_putOrMergeEntityAsyncImpl(
            $table,
            $entity,
            Resources::HTTP_MERGE,
            false,
            $options
        );
    }

    /**
     * Replaces an existing entity or inserts a new entity if it does not exist in
     * the table.
     *
     * @param string                     $table   name of the table
     * @param Models\Entity              $entity  table entity
     * @param Models\TableServiceOptions $options optional parameters
     *
     * @return Models\UpdateEntityResult
     *
     * @see http://msdn.microsoft.com/en-us/library/windowsazure/hh452242.aspx
     */
    public function insertOrReplaceEntity(
        $table,
        Models\Entity $entity,
        Models\TableServiceOptions $options = null
    ) {
        return $this-&gt;insertOrReplaceEntityAsync(
            $table,
            $entity,
            $options
        )-&gt;wait();
    }

    /**
     * Creates a promise to replace an existing entity or inserts a new entity if it does not exist in the table.
     *
     * @param string                     $table   name of the table
     * @param Models\Entity              $entity  table entity
     * @param Models\TableServiceOptions $options optional parameters
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     *
     * @see http://msdn.microsoft.com/en-us/library/windowsazure/hh452242.aspx
     */
    public function insertOrReplaceEntityAsync(
        $table,
        Models\Entity $entity,
        Models\TableServiceOptions $options = null
    ) {
        return $this-&gt;_putOrMergeEntityAsyncImpl(
            $table,
            $entity,
            Resources::HTTP_PUT,
            false,
            $options
        );
    }

    /**
     * Updates an existing entity in a table. The Update Entity operation replaces
     * the entire entity and can be used to remove properties.
     *
     * @param string                     $table   The table name.
     * @param Models\Entity              $entity  The table entity.
     * @param Models\TableServiceOptions $options The optional parameters.
     *
     * @return Models\UpdateEntityResult
     *
     * @see http://msdn.microsoft.com/en-us/library/windowsazure/dd179427.aspx
     */
    public function updateEntity(
        $table,
        Models\Entity $entity,
        Models\TableServiceOptions $options = null
    ) {
        return $this-&gt;updateEntityAsync($table, $entity, $options)-&gt;wait();
    }

    /**
     * Creates promise to update an existing entity in a table. The Update Entity
     * operation replaces the entire entity and can be used to remove properties.
     *
     * @param string                     $table   The table name.
     * @param Models\Entity              $entity  The table entity.
     * @param Models\TableServiceOptions $options The optional parameters.
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     *
     * @see http://msdn.microsoft.com/en-us/library/windowsazure/dd179427.aspx
     */
    public function updateEntityAsync(
        $table,
        Models\Entity $entity,
        Models\TableServiceOptions $options = null
    ) {
        return $this-&gt;_putOrMergeEntityAsyncImpl(
            $table,
            $entity,
            Resources::HTTP_PUT,
            true,
            $options
        );
    }

    /**
     * Updates an existing entity by updating the entity's properties. This operation
     * does not replace the existing entity, as the updateEntity operation does.
     *
     * @param string                     $table   The table name.
     * @param Models\Entity              $entity  The table entity.
     * @param Models\TableServiceOptions $options The optional parameters.
     *
     * @return Models\UpdateEntityResult
     *
     * @see http://msdn.microsoft.com/en-us/library/windowsazure/dd179392.aspx
     */
    public function mergeEntity(
        $table,
        Models\Entity $entity,
        Models\TableServiceOptions $options = null
    ) {
        return $this-&gt;mergeEntityAsync($table, $entity, $options)-&gt;wait();
    }

    /**
     * Creates promise to update an existing entity by updating the entity's
     * properties. This operation does not replace the existing entity, as the
     * updateEntity operation does.
     *
     * @param string                     $table   The table name.
     * @param Models\Entity              $entity  The table entity.
     * @param Models\TableServiceOptions $options The optional parameters.
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     *
     * @see http://msdn.microsoft.com/en-us/library/windowsazure/dd179392.aspx
     */
    public function mergeEntityAsync(
        $table,
        Models\Entity $entity,
        Models\TableServiceOptions $options = null
    ) {
        return $this-&gt;_putOrMergeEntityAsyncImpl(
            $table,
            $entity,
            Resources::HTTP_MERGE,
            true,
            $options
        );
    }

    /**
     * Deletes an existing entity in a table.
     *
     * @param string                     $table        The name of the table.
     * @param string                     $partitionKey The entity partition key.
     * @param string                     $rowKey       The entity row key.
     * @param Models\DeleteEntityOptions $options      The optional parameters.
     *
     * @return void
     *
     * @see http://msdn.microsoft.com/en-us/library/windowsazure/dd135727.aspx
     */
    public function deleteEntity(
        $table,
        $partitionKey,
        $rowKey,
        Models\DeleteEntityOptions $options = null
    ) {
        $this-&gt;deleteEntityAsync($table, $partitionKey, $rowKey, $options)-&gt;wait();
    }

    /**
     * Creates promise to delete an existing entity in a table.
     *
     * @param string                     $table        The name of the table.
     * @param string                     $partitionKey The entity partition key.
     * @param string                     $rowKey       The entity row key.
     * @param Models\DeleteEntityOptions $options      The optional parameters.
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     *
     * @see http://msdn.microsoft.com/en-us/library/windowsazure/dd135727.aspx
     */
    public function deleteEntityAsync(
        $table,
        $partitionKey,
        $rowKey,
        Models\DeleteEntityOptions $options = null
    ) {
        $context = $this-&gt;_constructDeleteEntityContext(
            $table,
            $partitionKey,
            $rowKey,
            $options
        );

        return $this-&gt;sendContextAsync($context);
    }

    /**
     * Gets table entity.
     *
     * @param string                     $table        The name of the table.
     * @param string                     $partitionKey The entity partition key.
     * @param string                     $rowKey       The entity row key.
     * @param Models\TableServiceOptions $options      The optional parameters.
     *
     * @return Models\GetEntityResult
     *
     * @see http://msdn.microsoft.com/en-us/library/windowsazure/dd179421.aspx
     */
    public function getEntity(
        $table,
        $partitionKey,
        $rowKey,
        Models\TableServiceOptions $options = null
    ) {
        return $this-&gt;getEntityAsync(
            $table,
            $partitionKey,
            $rowKey,
            $options
        )-&gt;wait();
    }

    /**
     * Creates promise to get table entity.
     *
     * @param string                     $table        The name of the table.
     * @param string                     $partitionKey The entity partition key.
     * @param string                     $rowKey       The entity row key.
     * @param Models\TableServiceOptions $options      The optional parameters.
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     *
     * @see http://msdn.microsoft.com/en-us/library/windowsazure/dd179421.aspx
     */
    public function getEntityAsync(
        $table,
        $partitionKey,
        $rowKey,
        Models\TableServiceOptions $options = null
    ) {
        Validate::isString($table, 'table');
        Validate::notNullOrEmpty($table, 'table');
        Validate::isTrue(!is_null($partitionKey), Resources::NULL_TABLE_KEY_MSG);
        Validate::isTrue(!is_null($rowKey), Resources::NULL_TABLE_KEY_MSG);

        $method      = Resources::HTTP_GET;
        $headers     = array();
        $queryParams = array();
        $path        = $this-&gt;_getEntityPath($table, $partitionKey, $rowKey);

        if (is_null($options)) {
            $options = new TableServiceOptions();
        }

        $this-&gt;addOptionalHeader(
            $headers,
            Resources::CONTENT_TYPE,
            Resources::XML_ATOM_CONTENT_TYPE
        );

        $context = new HttpCallContext();
        $context-&gt;setHeaders($headers);
        $context-&gt;setMethod($method);
        $context-&gt;setPath($path);
        $context-&gt;setQueryParameters($queryParams);
        $context-&gt;setStatusCodes(array(Resources::STATUS_OK));
        $context-&gt;setServiceOptions($options);

        $atomSerializer = $this-&gt;_atomSerializer;

        return $this-&gt;sendContextAsync($context)-&gt;then(
            function ($response) use ($atomSerializer) {
                return GetEntityResult::create(
                    $response-&gt;getBody(),
                    $atomSerializer
                );
            },
            null
        );
    }

    /**
     * Does batch of operations on the table service.
     *
     * @param Models\BatchOperations     $batchOperations The operations to apply.
     * @param Models\TableServiceOptions $options         The optional parameters.
     *
     * @return Models\BatchResult
     */
    public function batch(
        Models\BatchOperations $batchOperations,
        Models\TableServiceOptions $options = null
    ) {
        return $this-&gt;batchAsync($batchOperations, $options)-&gt;wait();
    }

    /**
     * Creates promise that does batch of operations on the table service.
     *
     * @param Models\BatchOperations     $batchOperations The operations to apply.
     * @param Models\TableServiceOptions $options         The optional parameters.
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function batchAsync(
        Models\BatchOperations $batchOperations,
        Models\TableServiceOptions $options = null
    ) {
        Validate::notNullOrEmpty($batchOperations, 'batchOperations');

        $method      = Resources::HTTP_POST;
        $operations  = $batchOperations-&gt;getOperations();
        $contexts    = $this-&gt;_createOperationsContexts($operations);
        $mime        = $this-&gt;_createBatchRequestBody($operations, $contexts);
        $body        = $mime['body'];
        $headers     = $mime['headers'];
        $postParams  = array();
        $queryParams = array();
        $path        = '$batch';

        if (is_null($options)) {
            $options = new TableServiceOptions();
        }

        $atomSerializer = $this-&gt;_atomSerializer;
        $mimeSerializer = $this-&gt;_mimeSerializer;

        $options-&gt;setLocationMode(LocationMode::PRIMARY_ONLY);

        return $this-&gt;sendAsync(
            $method,
            $headers,
            $queryParams,
            $postParams,
            $path,
            Resources::STATUS_ACCEPTED,
            $body,
            $options
        )-&gt;then(function ($response) use (
            $operations,
            $contexts,
            $atomSerializer,
            $mimeSerializer
        ) {
            return BatchResult::create(
                $response-&gt;getBody(),
                $operations,
                $contexts,
                $atomSerializer,
                $mimeSerializer
            );
        }, null);
    }

    /**
     * Gets the access control list (ACL)
     *
     * @param string                     $table   The table name.
     * @param Models\TableServiceOptions $options The optional parameters.
     *
     * @return Models\TableACL
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/get-table-acl
     */
    public function getTableAcl(
        $table,
        Models\TableServiceOptions $options = null
    ) {
        return $this-&gt;getTableAclAsync($table, $options)-&gt;wait();
    }

    /**
     * Creates the promise to gets the access control list (ACL)
     *
     * @param string                     $table   The table name.
     * @param Models\TableServiceOptions $options The optional parameters.
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/get-table-acl
     */
    public function getTableAclAsync(
        $table,
        Models\TableServiceOptions $options = null
    ) {
        Validate::isString($table, 'table');
        
        $method      = Resources::HTTP_GET;
        $headers     = array();
        $postParams  = array();
        $queryParams = array();
        $statusCode  = Resources::STATUS_OK;
        $path        = $table;
        
        if (is_null($options)) {
            $options = new TableServiceOptions();
        }
        
        $this-&gt;addOptionalQueryParam(
            $queryParams,
            Resources::QP_COMP,
            'acl'
        );

        $dataSerializer = $this-&gt;dataSerializer;
        
        $promise = $this-&gt;sendAsync(
            $method,
            $headers,
            $queryParams,
            $postParams,
            $path,
            Resources::STATUS_OK,
            Resources::EMPTY_STRING,
            $options
        );

        return $promise-&gt;then(function ($response) use ($dataSerializer) {
            $parsed       = $dataSerializer-&gt;unserialize($response-&gt;getBody());
            return TableACL::create($parsed);
        }, null);
    }
    
    /**
     * Sets the ACL.
     *
     * @param string                     $table   name
     * @param Models\TableACL            $acl     access control list for Table
     * @param Models\TableServiceOptions $options optional parameters
     *
     * @return void
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/set-table-acl
     */
    public function setTableAcl(
        $table,
        Models\TableACL $acl,
        Models\TableServiceOptions $options = null
    ) {
        $this-&gt;setTableAclAsync($table, $acl, $options)-&gt;wait();
    }

    /**
     * Creates promise to set the ACL
     *
     * @param string                     $table   name
     * @param Models\TableACL            $acl     access control list for Table
     * @param Models\TableServiceOptions $options optional parameters
     *
     * @return \GuzzleHttp\Promise\PromiseInterface
     *
     * @see https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/set-table-acl
     */
    public function setTableAclAsync(
        $table,
        Models\TableACL $acl,
        Models\TableServiceOptions $options = null
    ) {
        Validate::isString($table, 'table');
        Validate::notNullOrEmpty($acl, 'acl');
        
        $method      = Resources::HTTP_PUT;
        $headers     = array();
        $postParams  = array();
        $queryParams = array();
        $body        = $acl-&gt;toXml($this-&gt;dataSerializer);
        $path        = $table;
        
        if (is_null($options)) {
            $options = new TableServiceOptions();
        }
        
        $this-&gt;addOptionalQueryParam(
            $queryParams,
            Resources::QP_COMP,
            'acl'
        );

        $options-&gt;setLocationMode(LocationMode::PRIMARY_ONLY);
        
        return $this-&gt;sendAsync(
            $method,
            $headers,
            $queryParams,
            $postParams,
            $path,
            Resources::STATUS_NO_CONTENT,
            $body,
            $options
        );
    }
}
</pre>
        <script type="text/javascript">
             SyntaxHighlighter.all();
             jQuery('.gutter div').each(function(key, data){
                jQuery(data).prepend('<a name="L'+jQuery(data).text()+'"/>');
             });
        </script>
    </body>
</html>